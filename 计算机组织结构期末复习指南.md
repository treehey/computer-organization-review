# **计算机组织结构期末复习指南 (第一阶段)**

## **目录与分值分布 (Total: \~25分)**

1. **计算机系统概述** (约 5分)  
   * *题型预测：选择题、简答题、计算题(CPU时间/Amdahl)*  
2. **数据的机器级表示** (约 10分)  
   * *题型预测：选择题、填空题、计算题(IEEE754转换/补码范围)*  
3. **运算方法和运算部件** (约 10分)  
   * *题型预测：选择题(标志位判断)、计算题(补码加减/溢出)*

---

# **第一部分：计算机系统概述 (约 5分)**

### **1\. 核心考点与答案**

* **计算机硬件的基本组成?**  
  * **冯·诺依曼结构五大部件**：运算器、控制器、存储器、输入设备、输出设备。  
  * **现代计算机核心**：CPU (运算器+控制器+寄存器) + 主存 + 总线 + I/O设备。  
* **计算机软件的分类?**  
  * **系统软件**：操作系统 (OS)、语言处理程序 (编译器/汇编器)、数据库管理系统 (DBMS)。用于管理硬件和支持应用。  
  * **应用软件**：为特定任务编写的程序 (如视频播放器、Office)。  
* **计算机系统的抽象层及其转换?**  
  * **层次**：应用 $\to$ 算法 $\to$ 编程语言 $\to$ OS/虚拟机 $\to$ **ISA (指令集体系结构)** $\to$ 微体系结构 $\to$ 硬件电路。  
  * **关键**：**ISA** 是软硬件的接口 (Interface)。  
  * **转换**：源程序(.c) $\xrightarrow{预处理}$ .i $\xrightarrow{编译}$ .s (汇编) $\xrightarrow{汇编}$ .o (机器码) $\xrightarrow{链接}$ 可执行文件。  
* **用户CPU时间计算?** (★重点计算)  
  * 公式：

    $$
    \text{用户CPU时间} = \frac{\text{程序总时钟周期数}}{\text{时钟频率}}
    $$
    $$
    = \text{指令条数(IC)} \times \text{CPI} \times \text{时钟周期}
    $$
  * **CPI (Cycles Per Instruction)**：执行每条指令所需的平均时钟周期数。  
* **Amdahl定律?** (★重点计算)  
  * 用于计算系统某部分改进后的整体加速比。  
  * 公式：

    $$
    \text{加速比} = \frac{1}{(1-f) + \frac{f}{S}}
    $$  
  * $f$：可改进部分占总时间的比例。  
  * $S$：改进部分性能提高的倍数。  
  * **结论**：系统加速比受限于不可改进部分 ($1-f$)，即使 $S \to \infty$，加速比极限为 $1/(1-f)$。

### **2\. 典型例题**

* **CPU时间**：已知 A 机频率 400MHz，运行需 10s。设计 B 机运行需 6s，但周期数增加 1.2 倍。求 B 机频率？  
  * $Cycle\_A = 10 \times 400M = 4000M$  
  * $Cycle\_B = 1.2 \times 4000M = 4800M$  
  * $Freq\_B = 4800M / 6s = 800MHz$。

---

# **第二部分：数据的机器级表示 (约 10分)**

### **1\. 核心考点与答案**

* **数制转换 (二/八/十/十六)?**  
  * **二 $\to$ 十六**：4位一组 (1011 0101 $\to$ B5)。  
  * **十 $\to$ R**：整数除基取余 (上低下高)，小数乘基取整 (上高下低)。  
* **整数表示 (原码/补码/移码)?**  
  * **补码 (Two's Complement)**：正数不变；负数**取反加1**。  
  * **小数** (补码)：小数点固定在符号位后 (如 \`1.xxxx\`)。
  * **转换规则 (原 $\to$ 补)**：  
        * **正小数**：符号位 0，数值位不变。  
        * **负小数**：符号位 1，数值位**按位取反，末位加 1**。  
        * **示例**：$x = -0.1011$  
          1. 写出原码：$1.1011$  
          2. 数值取反：$1.0100$ (符号位不变)  
          3. 末位加一：**$1.0101$** (即为补码)  
      * **注意**：定点小数补码范围为 $-1 \le x \le 1 - 2^{-n}$ (其中 $-1$ 的补码规定为 \`1.000...0\`)。
  * **移码**：补码符号位取反 (用于浮点数阶码，方便比较大小)。  
* **无符号与带符号整数?**  
  * **范围 (n位)**：  
    * 无符号：$0 \sim 2^n - 1$。  
    * 补码：$-2^{n-1} \sim 2^{n-1} - 1$ (注意最小负数无对应原码)。  
  * **转换**：机器码不变，解释方式不同。  
* **浮点数表示 (IEEE 754)?** (★重点计算)  
  * **公式**：$V = (-1)^S \times 1.M \times 2^{E - Bias}$  
  * **参数**：  
    * **单精度 (32位)**：S(1) + E(8) + M(23)。Bias = 127。  
    * **双精度 (64位)**：S(1) + E(11) + M(52)。Bias = 1023。  
  * **阶码 E**：全0为非规格化数 (0或极小)，全1为 $\infty$ 或 NaN。  
* **数据的存储和排列顺序?**  
  * **大端 (Big Endian)**：高位存低地址 (MSB First)。  
  * **小端 (Little Endian)**：低位存低地址 (LSB First, Intel x86用此方式)。  
  * **对齐**：int (4字节) 地址应能被 4 整除，否则可能触发异常或降低效率。

### **2\. 典型例题**

* **十六进制转浮点**：C0A00000H 是多少？  
  * 二进制：1 10000001 01000...  
  * S=1 (负)。E=129 (真值 $129-127=2$)。M=.01 (真值 $1.25$)。  
  * 值 = $-1.25 \times 2^2 = -5.0$。  
* **大端小端**：0x12345678 存入地址 0，机器是小端。问地址 0 存什么？  
  * 答案：0x78 (最低位)。

---

# **第三部分：运算方法和运算部件 (约 10分)**

### **1\. 核心考点与答案**

* **常见的 MIPS 汇编指令?**  
  * **算术运算**：  
    * `add $t0, $s1, $s2`(带符号加，溢出报错)  
    * `addu $t0, $s1, $s2` (无符号加，**不**报溢出)  
    * `sub $t0, $s1, $s2 ` 
    * `addi $t0, $s1, 10`(立即数加)  
  * **逻辑运算**：  
    * `and $t0, $s1, $s2` (按位与，用于掩码)  
    * `or $t0, $s1, $s2` (按位或，用于置位)  
    * `nor $t0, $s1, $s2` (按位或非，用于取反 nor $t0, $s1, $zero)  
  * **移位运算**：  
    * `sll $t0, $s1, 2` (逻辑左移，低位补0)  
    * `srl $t0, $s1, 2` (逻辑右移，高位补0)  
    * `sra $t0, $s1, 2` (算术右移，高位补**符号位**)  
* **加法器原理?**  
  * **串行进位**：延迟高，随位数线性增加。  
  * **并行进位 (CLA)**：利用生成项 ($G$) 和传递项 ($P$) 提前计算进位，速度快。  
  * **ALU 标志位**：  
    * **ZF** (结果为0)  
    * **OF** (带符号溢出：$C\_n \oplus C\_{n-1}$)  
    * **CF** (无符号进位/借位：$C\_{out} \oplus C\_{in}$)  
    * **SF** (结果符号：最高位)  
* **补码加减运算与溢出?** (★重点)  
  * **公式**：$[A-B]_{\text{补}} = [A]_{\text{补}} + [-B]_{\text{补}}$。  
  * **溢出判断**：  
    * **方法1**：最高位进位 $\ne$ 次高位进位 ($C\_n \oplus C\_{n-1} = 1$)。  
    * **方法2**：双符号位 (01正溢出，10负溢出)。  
* **浮点数加减运算?**  
  * **步骤**：**对阶** (小阶看齐大阶) $\to$ **尾数加减** $\to$ **规格化** (左规/右规) $\to$ **舍入** $\to$ **溢出判断**。  
  * **精度损失**：主要发生在对阶(右移)和舍入时。

### **2\. 典型例题**

* **补码加法溢出**：8位补码 10000000 + 10000000 (-128 + -128)  
  * 结果 1 00000000 (9位)。  
  * 8位截断后为 00000000 (0)。  
  * $C\_n=1$ (符号位进位), $C\_{n-1}=0$ (数值最高位无进位)。  
  * $OF = 1 \oplus 0 = 1$ (溢出)。  
* **常量乘法**：计算 x \* 10。  
  * MIPS指令思路：sll $t0, $s0, 3 ($x \times 8$) $\to$ sll $t1, $s0, 1 ($x \times 2$) $\to$ add $t0, $t0, $t1。

---

# **第四部分：指令系统 (约15分)**

## **一、 考试重点与题型预测**

根据《总复习》大纲，本章考查重点包括：

1. **指令的组成**：操作码（OP）+ 操作数地址。  
2. **MIPS 三种指令格式**：R型、I型、J型的字段划分及位宽。  
3. **寻址方式**：立即数寻址、寄存器寻址、基址寻址、PC 相对寻址、伪直接寻址。  
4. **C 语言结构的汇编表示**：if-else、while/for 循环的实现。  
5. **过程调用 (Function Call)**：栈（Stack）的变化、寄存器使用约定（$a0-$a3, $v0-$v1, $ra, $sp）。

---

**二、 核心知识点详解**

### **1\. MIPS 指令格式 (必考)**

MIPS 指令长度固定为 **32位**，分为三种格式：

| 格式 | op (6bit) | rs (5) | rt (5) | rd (5) | shamt (5) | funct (6) | 说明 |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| **R型** | 0 | 源1 | 源2 | 目 | 移位量 | 功能码 | 算术/逻辑运算 |
| **I型** | op | 源1 | 源/目 | 16位立即数 / 地址偏移量 | \- | \- | 访存、立即数、分支 |
| **J型** | op | 26位目标地址 (Target Address) | \- | \- | \- | \- | 无条件跳转 |

* **注意**：lw (取数) 指令中，rt 是存放结果的目标寄存器；sw (存数) 指令中，rt 是源寄存器。

### **2\. 五种寻址方式 (Addressing Modes)**

1. **立即数寻址 (Immediate)**：操作数就在指令中（I型）。  
2. **寄存器寻址 (Register)**：操作数在寄存器中（R型）。  
3. **基址寻址 (Base/Displacement)**：地址 = 寄存器内容 + 16位偏移量（用于 lw, sw）。  
4. **PC相对寻址 (PC-Relative)**：地址 = (PC+4) + 偏移量 $\times$ 4（用于 beq, bne 分支）。  
5. **伪直接寻址 (Pseudo-direct)**：地址 = (PC+4)的高4位 + 26位立即数 $\times$ 4（用于 j, jal）。

### **3\. C 语言控制结构的翻译**

* **条件分支 (if-else)**：  
  * 使用 beq (相等跳转) 或 bne (不相等跳转)。  
  * 配合无条件跳转 j 跳过 else 部分。  
* **循环 (while/for)**：  
  * 在循环体开始处设置标签（如 loop:）。  
  * 在循环结束处使用 j loop 跳回。  
  * 在进入循环或循环末尾判断退出条件。

### **4\. 过程调用与栈帧 (Procedure Call)**

过程调用的核心步骤（JAL/JR）：

1. **参数传递**：由调用者将参数放入 $a0-$a3。  
2. **控制转移**：执行 jal Label（保存返回地址到 $ra 并跳转）。  
3. **保存现场**：被调用者若要使用 $s0-$s7 或再次调用函数，需将 $ra 和寄存器压入**栈 (Stack)**。  
4. **执行并返回结果**：结果存入 $v0-$v1。  
5. **恢复现场与返回**：从栈中弹出数据，执行 jr $ra 返回。  
* **栈帧结构**：$sp (栈指针) 指向栈顶，向低地址增长。

---

**三、 典型题型与做题技巧**

### **1\. 指令解析与机器码转换**

题目：将 lw $t0, 12($s0) 转换为机器码。  
解析：

1. 查表得知 lw 的 op 为 35 (100011)。  
2. $s0 是寄存器 16 (10000)，对应 rs。  
3. $t0 是寄存器 8 (01000)，对应 rt。  
4. 立即数为 12 (0000 0000 0000 1100)。  
5. **拼接**：100011 10000 01000 0000000000001100。

### **2\. C 翻译为汇编 (常考)**

题目：if (i == j) f = g + h; else f = g \- h; (假设 f\~j 分别在 $s0~$s4)  
答案：

MIPS Assembler

      bne $s3, $s4, Else  \# if i \!= j, goto Else  
      add $s0, $s1, $s2   \# f = g + h  
      j Exit              \# skip Else  
Else: sub $s0, $s1, $s2   \# f = g \- h  
Exit:

### **3\. 栈操作计算**

题目：在函数开始处需要保存 3 个寄存器，如何操作 $sp？  
答案：

MIPS Assembler

addi $sp, $sp, \-12   \# 栈向低地址增长，3个字=12字节  
sw $ra, 8($sp)  
sw $s1, 4($sp)  
sw $s0, 0($sp)

---

# **第五部分：中央处理器 (约15分)**

## **一、 核心考点与答案**

#### **1\. CPU 执行指令的过程？**

**【答案要点】**

1. **取指令 (Fetch)**：根据 PC 从主存中取出指令，PC 增量（PC + 4）。  
2. **指令译码 (Decode)**：解析指令操作码，读取寄存器操作数。  
3. **执行 (Execute)**：利用 ALU 进行算术/逻辑运算或地址计算。  
4. **访存 (Memory)**：如果是 lw/sw 指令，则访问数据存储器。  
5. **写回 (Write Back)**：将结果写回目标寄存器（如 R 型指令或 lw）。  
* *注意：每步都要检测异常，执行末尾检测中断。*

#### **2\. CPU 的基本组成？操作元件与状态元件的区别？**

**【答案要点】**

* **基本组成**：由**数据通路 (Datapath)** 和 **控制器 (Control Unit)** 组成。  
* **操作元件 (组合逻辑)**：输出只取决于当前输入。如：ALU、加法器、多路选择器 (Mux)、译码器。  
* **状态元件 (时序逻辑)**：具有存储功能，在时钟边沿更新。如：寄存器、PC、存储器。

#### **3\. 指令周期与时钟周期？**

* **指令周期**：执行一条指令所花费的总时间。  
* **时钟周期**：CPU 操作的最小单位（频率的倒数）。  
* **单周期 CPU**：指令周期 = 时钟周期（所有指令在一个时钟内完成）。  
* **多周期 CPU**：指令周期 = $N \times$ 时钟周期（不同指令步数不同）。

#### **4\. 单周期数据通路与控制信号？ (★核心重点)**

【答案要点】  
必须掌握以下 7 个核心控制信号在不同指令下的取值：

| 控制信号 | 功能描述 | R型 (add/sub) | lw (取数) | sw (存数) | beq (分支) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **RegDst** | 写寄存器选择 (rt还是rd) | **1 (rd)** | 0 (rt) | X | X |
| **RegWrite** | 是否写寄存器 | **1** | **1** | 0 | 0 |
| **ALUSrc** | ALU第二个输入 (寄存器还是立即数) | 0 (reg) | **1 (imm)** | **1 (imm)** | 0 (reg) |
| **MemtoReg** | 写回寄存器的数据源 (ALU还是内存) | 0 (ALU) | **1 (Mem)** | X | X |
| **MemWrite** | 是否写内存 | 0 | 0 | **1** | 0 |
| **Branch** | 是否是分支指令 | 0 | 0 | 0 | **1** |
| **ExtOp** | 立即数扩展方式 (0扩展还是符号扩展) | X | 1 (符号) | 1 (符号) | 1 (符号) |

#### **5\. 多周期处理器设计？**

**【答案要点】**

* **设计动机**：单周期时钟周期由最慢的指令（lw）决定，浪费严重。多周期通过将指令分解为多个时钟步，让快指令执行短时间，慢指令执行长时间。  
* **状态转换**：使用**有限状态机 (FSM)** 控制。  
  * Step 1: 取指 (所有指令相同)  
  * Step 2: 译码/读寄存器 (所有指令相同)  
  * Step 3: 执行/地址计算/分支完成  
  * Step 4: 访存读/写回 R 型指令  
  * Step 5: lw 写回寄存器

#### **6\. 微程序控制器基本思想？**

**【答案要点】**

* 将每一条机器指令编写成一段微程序。  
* 微程序由多条**微指令**组成，每条微指令产生一组微操作信号。  
* 优点：设计规整、灵活、易于修改和扩充指令。

### **7\. 带异常处理的数据通路 (Exception Handling)

**【考点说明】**
异常处理要求 CPU 在执行指令时，能够检测到特殊事件（如溢出、非法指令等）并跳转到预定义的**异常处理程序入口地址**（在 MIPS 中通常是 `0x80000180`）。

**【核心改动/硬件支持】**
要在原有数据通路上支持异常，硬件上需要增加以下部件：
* **EPC (Exception Program Counter)**：一个特殊的寄存器，用于保存发生异常时的那条指令的地址，以便异常处理完后能返回原程序。
* **Cause 寄存器**：记录异常发生的原因（例如：溢出对应代码 12，非法指令对应代码 10）。
* **多路选择器 (Mux) 扩展**：在 PC 的输入端增加输入口。当异常发生时，通过控制信号将 PC 强制置为异常处理程序的入口地址。
* **控制逻辑修改**：当 ALU 检测到溢出（Overflow）信号时，必须将 `RegWrite` 信号置为 0（防止错误的结果被写入寄存器），并触发 PC 的跳转。

---

### **8\. 多周期处理器的有限状态机 (FSM)

**【考点说明】**
多周期处理器的控制器是一个**时序电路**。它通过有限状态机（FSM）来控制每一条指令在不同的时钟周期内应该开启哪些控制信号。

**【指令执行的 5 个典型状态】**
* **S0 (Fetch - 取指)**：执行 `IR = Memory[PC]; PC = PC + 4;`
* **S1 (Decode - 译码)**：读取寄存器堆，同时 ALU 预计算分支目标地址。
* **S2 (Execution - 执行)**：
    * **R型**：`ALUOut = A op B;`
    * **访存**：`ALUOut = A + Offset;`
    * **分支**：`if (A == B) PC = ALUOut;`（此时指令完成）
* **S3 (Memory Access / R-type Completion - 访存或R型写回)**：
    * **lw**：`Data = Memory[ALUOut];`
    * **sw**：`Memory[ALUOut] = B;`（此时指令完成）
    * **R型**：`Reg[rd] = ALUOut;`（此时指令完成）
* **S4 (Write-back - 写回)**：
    * **lw**：`Reg[rt] = Data;`（此时指令完成）

**【常见考试题型】**
* **状态转换图**：要求能画出不同指令在 S1 之后的分支路径（如 `lw` 需要走 S2->S3->S4，而 `beq` 在 S2 结束后就回到 S0）。
* **控制信号取值**：掌握每个状态下关键信号的状态。例如：在 **S0** 状态，`IRWrite` 必须有效（为 1）以锁存指令；在 **S3** 状态执行 `sw` 时，`MemWrite` 必须为 1。

---

**二、 典型题型与计算公式**

### **1\. 性能分析 (单周期 vs 多周期)**

公式：

$$\text{CPU时间} = \text{指令数} \times \text{CPI} \times \text{时钟周期}$$

* 单周期：CPI = 1。时钟周期 $T$ 极大（由最慢指令决定）。  
* 多周期：CPI \> 1。时钟周期 $t$ 极小（由单步操作决定）。

### **2\. 控制信号分析题 (课后习题重点)**

题目：如果控制信号 RegWrite 在任何情况下总是为 0，哪些指令无法执行？  
答案：所有需要写回寄存器的指令都无法执行，如 R 型指令 (add, sub) 和 lw。但 sw 和 beq 可以正常执行，因为它们不写寄存器。

### **3\. swap 指令扩展题**

**题目**：实现 swap rs, rt。

* **伪指令方式**：不需要额外寄存器。  
  MIPS Assembler  
  xor $rs, $rs, $rt  
  xor $rt, $rs, $rt  
  xor $rs, $rs, $rt

* **硬件实现**：需要修改数据通路，增加读写口，可能导致时钟周期变长。

---

**三、 复习建议 (整理进文档)**

1. **熟练画出局部数据通路**：例如，仅包含 beq 的路径或仅包含 lw 的路径。  
2. **背诵控制信号表**：这是考试中选择题和计算题填表的必拿分项。  
3. **理解 PC 更新逻辑**：  
   * 顺序：$PC = PC + 4$  
   * 分支：$PC = (PC+4) + \text{offset} \times 4$  
   * 跳转：$PC = (PC+4)\_{31:28} \\mid (\text{address} \times 4)$

---

# 第六部分：指令流水线 (约 15分)

## 1. 流水线基本概念与硬件实现

### (1) 五级流水段功能划分
MIPS 指令执行过程被划分为五个独立的功能段，每个时钟周期完成一个阶段：
* **IF (Instruction Fetch, 取指)**：根据 PC 值从指令存储器取出指令，同时计算 $PC + 4$。
* **ID (Instruction Decode, 译码/读寄存器)**：产生指令执行所需的控制信号，从寄存器堆读取操作数，并对立即数进行符号扩展。
* **EX (Execute, 执行/计算地址)**：ALU 执行算术/逻辑运算、计算访存地址（Load/Store）或计算分支目标地址（Branch）。
* **MEM (Memory Access, 访存)**：如果是访存指令，则根据 EX 段计算的地址访问数据存储器进行读/写。
* **WB (Write Back, 写回)**：将 ALU 的运算结果或从内存读出的数据写回寄存器堆。

### (2) 流水段寄存器 (Pipeline Registers)
为了实现指令的并行处理，必须在相邻的流水段之间插入寄存器，用于锁存当前段产生的、下一段所需的全部信息：
* **IF/ID**：保存取出的 32 位指令字和 $PC+4$。
* **ID/EX**：保存两个寄存器操作数、符号扩展后的立即数、寄存器编号（rt, rd）以及**所有控制信号**。
* **EX/MEM**：保存 ALU 的运算结果、Zero 标志位、写寄存器编号及要写入内存的数据。
* **MEM/WB**：保存从内存读出的数据、ALU 的运算结果以及写寄存器编号。



### (3) 控制信号的取值与传递
在流水线中，控制信号是在 **ID 阶段**一次性产生的，但它们必须随着指令在流水线中流动，在对应的阶段发挥作用：
* **EX段信号**：`RegDst`（选择写目的寄存器）、`ALUOp`、`ALUSrc`。
* **MEM段信号**：`Branch`、`MemRead`、`MemWrite`。
* **WB段信号**：`RegWrite`（写使能）、`MemtoReg`（写回源选择）。
* **设计要点**：控制信号被存储在流水段寄存器中逐级向后传递，确保控制逻辑与指令同步。

---

## 2. 流水线冒险 (Hazards) 及解决方法 —— ★大题核心

### (1) 结构冒险 (Structural Hazard)
* **现象**：硬件资源不足，无法支持多条指令同时执行。
* **解决方法**：
    * **哈佛结构**：物理上分离指令存储器和数据存储器。
    * **寄存器访问优化**：规定寄存器堆在**前半周期写、后半周期读**。

### (2) 数据冒险 (Data Hazard) —— 转发技术
* **现象**：指令需要前序指令尚未写回寄存器堆的计算结果。
* **核心对策：转发 (Forwarding/Bypassing)**
    * **EX冲突**：前指令在 EX/MEM 寄存器中有结果，当前指令在 EX 阶段需要。
    * **MEM冲突**：前前指令在 MEM/WB 寄存器中有结果，当前指令在 EX 阶段需要。
* **转发检测条件**（以 rs 为例）：
    * `if (EX/MEM.RegWrite and EX/MEM.RegisterRd != 0 and EX/MEM.RegisterRd == ID/EX.RegisterRs)` $\rightarrow$ 从 EX/MEM 转发。



### (3) Load-Use 冲突 (必须停顿)
* **现象**：`lw` 指令的数据在 MEM 段结束后才可用，紧跟其后的指令无法仅靠转发获得。
* **处理方法**：**必须阻塞 (Stall)** 一个时钟周期。硬件会清空 ID/EX 寄存器（插入 nop），并保持 PC 和 IF/ID 寄存器不变。

### (4) 控制冒险 (Control Hazard)
* **现象**：分支指令（如 `beq`）在结果确定前，后续指令已经进入流水线。
* **对策**：
    * **静态预测**：总是预测不跳转（Predict Not Taken）。
    * **动态预测**：使用分支预测表（BHT）记录历史跳转情况。
    * **延迟分支 (Delayed Branch)**：在分支指令后放入一条总是需要执行的指令（填充延迟槽）。

---

## 3. 异常与中断的处理
* **流水线处理原则**：实现**精确异常 (Precise Exception)**。
* **步骤**：
    1.  清空引起异常指令及其后的所有指令（插入 nop）。
    2.  将异常指令地址保存到 **EPC**。
    3.  记录异常原因到 **Cause** 寄存器。
    4.  跳转到异常处理入口地址（如 `0x80000180`）。

---

## 典型题型分析

**公式总结：**
* **流水线时钟周期** = $\max(\text{各段延迟}) + \text{流水段寄存器延迟}$。
* **加速比** = $\frac{\text{单周期总执行时间}}{\text{流水线时钟周期}}$（在不考虑冒险停顿的理想状态下 $\approx$ 级数）。
* **指令执行总时间** = $(k + n - 1 + \text{Stall}) \times \text{时钟周期}$（$k$ 为段数，$n$ 为指令数）。

**做题技巧：**
1.  **找相关性**：先看指令的寄存器使用情况，确定是否存在“写后读(RAW)”关系。
2.  **看指令类型**：如果是 `lw` 后跟引用指令，必须多算一个周期停顿。
3.  **注意转发位置**：转发通常是从流水寄存器（EX/MEM 或 MEM/WB）到 ALU 的输入端。

---

# 第七部分：存储器层次结构 (约 20分)

## 1. 存储器概述与层次结构

### (1) 存储器分类、主存组成与操作
* **分类**：
    * **按存取方式**：随机存取 (RAM)、顺序存取 (SAM，如磁带)、直接存取 (DAM，如磁盘)。
    * **按工作性质**：易失性 (RAM)、非易失性 (ROM)。
* **主存储器组成**：由**存储阵列 (Bank)**、**地址译码驱动电路**、**读写电路**以及 **MAR** (地址寄存器) 和 **MDR** (数据寄存器) 组成。
* **基本操作**：
    * **读操作**：CPU 将地址送入 MAR -> 译码选通单元 -> 读电路将内容送入 MDR。
    * **写操作**：CPU 将地址送入 MAR，数据送入 MDR -> 译码选通单元 -> 写电路将数据存入单元。

### (2) 存储器的层次化结构
* **结构**：寄存器 $\rightarrow$ Cache $\rightarrow$ 主存 $\rightarrow$ 辅存。
* **基本原理**：**程序访问的局部性**。
    * **时间局部性**：最近访问过的数据项很快会再次被访问（如循环）。
    * **空间局部性**：地址相近的数据项很快会再次被访问（如数组、顺序执行指令）。

---

## 2. 半导体存储器与芯片扩展

### (1) SRAM 和 DRAM 的区别
| 特性 | SRAM (静态RAM) | DRAM (动态RAM) |
| :--- | :--- | :--- |
| **存储原理** | 双稳态触发器 (6管) | 电容电荷 (1管) |
| **刷新** | 不需要 | **需要 (定期刷新电荷)** |
| **速度** | 快 (命中时间短) | 慢 |
| **集成度/成本** | 低 / 贵 | 高 / 便宜 |
| **常用场景** | **Cache** | **主存** |

### (2) 存储器芯片的扩展
* **位扩展**：增加存储字长。地址线并联，数据线分别接到不同的 I/O。
* **字扩展**：增加存储单元个数。地址线高位通过**译码器**产生**片选信号 (CS)**。

### (3) 多模块存储器编址
* **连续编址 (高位交叉)**：高位选模块，低位选单元。同一模块地址连续，便于扩容。
* **交叉编址 (低位交叉)**：低位选模块，高位选单元。
    * **特点**：相邻地址在不同模块，支持**流水式并行访问**，显著提高带宽。

---

## 3. 辅存与数据校验

### (1) 磁盘读写与性能
* **读写三步骤**：**寻道** (磁头移到磁道) $\rightarrow$ **旋转** (等待扇区转到磁头下) $\rightarrow$ **传输** (读写数据)。
* **性能指标**：
    * **容量**：格式化 vs 非格式化容量。
    * **平均存取时间** = 平均寻道时间 + 平均等待时间 (转半圈) + 传输时间。

### (2) 数据校验
* **原理**：增加冗余位，建立校验位与数据位之间的逻辑关系。
* **奇偶校验 (Parity)**：增加 1 位使 1 的个数为奇或偶。只能检错 (1位)，不能纠错。
* **循环冗余校验 (CRC)**：利用模2除法产生余数作为校验码。常用于磁盘数据传输。

---
## 4. 程序访问的局部性 (Locality of Reference) —— ★理论基石

**【考点说明】**
程序在执行时，所访问的指令和数据往往集中在较小的地址范围内。这是存储器分层结构（寄存器-Cache-主存-外存）能够以较低成本获得接近最高速设备性能的理论依据。

**【分类与定义】**：
1. **时间局部性 (Temporal Locality)**：
   - **定义**：如果一个信息项正在被访问，那么在近期它很可能再次被访问。
   - **典型例子**：循环体中的指令、循环中反复使用的累加变量。
2. **空间局部性 (Spatial Locality)**：
   - **定义**：如果一个存储单元被访问，那么与其相邻的存储单元在近期也很可能被访问。
   - **典型例子**：数组的顺序访问、顺序执行的指令序列。

**【应用】**：
- **Cache** 利用时间局部性保留常用数据，利用空间局部性以“块（Block）”为单位从主存调入数据。
- **虚拟存储器** 利用局部性原理，只将进程当前需要的页面调入主存。

---

## 5. 高速缓冲存储器 (Cache) —— ★大题必考

### (1) 基本工作原理
Cache 缓存主存中最活跃的副本。CPU 访存时首先访问 Cache，若命中则不访问主存。

### (2) 三种映射方式 (地址划分)
* **直接映射**：主存块映射到固定 Cache 行。地址 = `Tag + Index(行索引) + Offset(块内地址)`。
* **全相联映射**：主存块可映射到任意 Cache 行。地址 = `Tag + Offset`。
* **组相联映射**：组间直接映射，组内全相联。地址 = `Tag + Set Index(组索引) + Offset`。
    * *计算：组数 = 总行数 / 路数*。



### (3) 性能指标
* **命中率 (a)**、**缺失率 (1-a)**。
* **平均访问时间 (AMAT)** = 命中时间 + 缺失率 $\times$ 缺失损失。

### (4) 替换算法
* **FIFO (先进先出)**：换掉最早进入的块。
* **LRU (最近最少用)**：换掉最久未被使用的块（基于局部性，效果最好）。

### (5) 写策略
* **全写法 (Write Through)**：命中时同时写 Cache 和主存。简单，一致性好。
* **回写法 (Write Back)**：只写 Cache 并设置“脏位 (Dirty bit)”，该块被替换时才写回主存。效率高，减少访存。

---

## 6. 虚拟存储器 (Virtual Memory)

### (1) 基本概念
利用磁盘作为主存的后援，为进程提供比实际物理内存大得多的**虚拟地址空间**。

### (2) 进程虚拟地址空间划分
典型划分为：代码段 (Text)、数据段 (Data)、堆 (Heap)、栈 (Stack)。

### (3) 分页式虚拟存储器工作原理
* **页表 (Page Table)**：存放 VPN (虚拟页号) 到 PPN (物理页号) 的映射，存放在主存中。
* **地址转换**：
    1. CPU 给出虚拟地址 (VA)。
    2. **快表 (TLB)** 查找：命中则直接得 PPN。
    3. 若 TLB 缺失，查主存中的**页表**。命中则得 PPN 且更新 TLB；若页表项有效位为 0，触发**缺页异常**。
    4. **物理地址 (PA)** = PPN + 页内偏移 (Offset)。
    5. 使用 PA 访问 **Cache**。



### (4) 关键点总结
* **页内偏移量**：虚拟地址和物理地址的低位偏移量完全相同。
* **访存次数**：TLB 缺失时，至少需要 2 次主存访问（查页表 + 读数据）。TLB 命中则只需 1 次访存。

---
### 存储器计算题避坑指南：
1. **单位换算**：1KB = $2^{10}$ B，1MB = $2^{20}$ B。地址位数 $n$ 与容量 $2^n$ 对应。
2. **Cache 划分**：
   * 块内偏移位 = $\log_2(\text{块大小})$。
   * 组索引位 = $\log_2(\text{Cache组数})$。其中组数 = 行数 / 路数。
3. **虚实地址**：页内偏移量在虚拟地址和物理地址中是**完全一样**的。
4. **访存次数**：
   * 无 TLB 时：访问一次数据需要 2 次访存（1次页表 + 1次数据）。
   * 有 TLB 且命中：只需 1 次访存。

---

# 第八部分：系统互联及输入输出组织 (约 10分)

## 1. 外部设备与总线概述

### (1) 外设的分类与特点
* **分类**：输入设备（键盘、鼠标）、输出设备（显示器、打印机）、输入/输出设备（磁盘、网卡）。
* **特点**：
    * **异步性**：外设与 CPU 之间无统一时钟，工作步调不一致。
    * **实时性**：外设请求必须及时响应，否则可能导致数据丢失。
    * **复杂性**：不同外设的传输速率和数据格式差异巨大。

### (2) 外设与 CPU/主存的互连（总线与编址）
* **总线 (Bus)**：计算机部件之间共享的传输线路。分为**数据总线、地址总线、控制总线**。
* **I/O 接口的功能**：地址译码、数据缓冲、状态监测、控制逻辑。
* **I/O 端口编址方式**：
    * **统一编址 (Memory-mapped I/O)**：将 I/O 端口映射到内存地址空间。
        * *优点*：无需专门指令，使用访存指令（`lw`/`sw`）即可访问。
        * *缺点*：占用部分内存地址空间。MIPS 采用此方式。
    * **独立编址 (I/O-mapped I/O)**：专门的 I/O 地址空间，使用专门指令（如 `in`/`out`）访问。


### (3) 总线系统 (Bus System)

* **基本概念**：
  * **总线**：一组能为多个部件分时共享的公共信息传输线路。
  * **系统总线**：连接 CPU、主存、I/O 接口的总线。

* **总线三类线路及其功能**
  1.  **数据线 (Data Bus)**：双向传输。用于在 CPU、内存、I/O 接口之间传送数据（指令、操作数）。其位数（总线宽度）决定了单次传输的能力。
  2.  **地址线 (Address Bus)**：单向传输（由 CPU 发出）。用于指明操作数所在的存储单元地址或 I/O 端口地址。其位数决定了 CPU 的寻址范围。
  3.  **控制线 (Control Bus)**：传输控制信号（如读/写使能、请求/响应、时钟、复位）。用于协调各部件的操作。

---

## 2. I/O 数据传送控制方式 (★核心考点)

这是本章最重要的理论点，要求理解三种方式的原理及其演进逻辑。

### (1) 程序查询方式 (Programmed I/O / Polling)
* **原理**：CPU 通过执行程序，不断读取外设的状态寄存器，检查其是否准备就绪。
* **特点**：
    * **CPU 踏步等待**：在外设准备期间，CPU 无法做其他事。
    * **串行工作**：CPU 与外设完全串行，效率极低。

### (2) 程序中断方式 (Interrupt-driven I/O)
* **原理**：外设在准备好数据后主动向 CPU 发出中断请求，CPU 暂停当前程序转而执行中断服务程序（ISR）。
* **特点**：CPU 与外设**部分并行**；CPU 仅在数据准备好时介入，不再需要主动等待。

### (3) 直接存储器存取 (DMA)
* **原理**：由专门的 **DMA 控制器**接管总线控制权。
* **特点**：
    * **高度并行**：数据直接在**外设和主存**之间传输，不经过 CPU。
    * **介入点**：CPU 只在传输开始前（初始化）和结束后（中断告知完成）介入。
    * **适用场景**：适合高速、大批量数据的传输（如磁盘读写）。



---

## 3. 中断处理与屏蔽字计算 (★计算/简答题)

### (1) 中断处理全过程
1.  **中断请求**：外设发出信号。
2.  **中断响应**：CPU 在**当前指令执行结束时**检测并响应。
3.  **关中断**：禁止更高优先级的请求干扰。
4.  **保存断点**：将当前 PC 存入 **EPC**（或栈）。
5.  **识别中断源**：查表或向量中断。
6.  **保护现场**：保存通用寄存器。
7.  **执行 ISR**：执行真正的 I/O 操作。
8.  **恢复现场与开中断**。
9.  **中断返回**：执行 `eret` 或 `jr $ra` 返回原程序。

### (2) 中断优先级与屏蔽字
* **中断屏蔽字 (Interrupt Mask)**：每一位对应一个中断源。
    * **1**：表示屏蔽（该位对应的中断不能中断当前处理）。
    * **0**：表示允许（该位对应的中断可以嵌套执行）。
* **设置规律**：
    * 一般情况下，屏蔽字中对应**本级及所有低优先级**的位应设为 1。

---

## 4. 三种 DMA 传送方式 (DMA 冲突处理)

当 DMA 控制器与 CPU 同时竞争访问主存时，有三种解决方法：

1.  **CPU 停止法**：
    * **原理**：DMA 传送时，CPU 放弃总线控制权并停止工作，直到整个数据块传完。
    * **优点**：控制简单，适合高速设备。
    * **缺点**：CPU 闲置时间长，严重影响效率。

2.  **周期挪用法 (Cycle Stealing)**：
    * **原理**：DMA 每次申请挪用一个或几个总线周期来传输一个字。
    * **冲突处理**：若 CPU 不访存，则无冲突；若 CPU 正在访存，则 DMA 等待当前周期结束；若同时请求，**优先满足 DMA**。
    * **特点**：对 CPU 性能影响小，现代系统最常用。

3.  **交替分时访问法**：
    * **原理**：将一个 CPU 周期分为两半，$C_1$ 专供 CPU，$C_2$ 专供 DMA。
    * **特点**：总线控制权按固定比例分配，CPU 和 DMA 互不干扰，但硬件实现复杂。

---

## 5. I/O 子系统的层次结构

### (1) 软硬件层次划分
1.  **用户层 I/O 软件**：通过库函数（如 `printf`）发出 I/O 请求。
2.  **设备独立性软件**：逻辑 I/O。处理对所有设备通用的功能（如缓冲、纠错、独占设备管理）。
3.  **设备驱动程序**：与具体硬件直接通信，将逻辑指令转换为特定的设备寄存器操作。
4.  **中断处理程序**：当 I/O 完成时，负责唤醒等待的驱动程序。
5.  **硬件层**：具体的控制器和外部设备。

### (2) 用户程序、C语言库、内核之间的关系
* **用户程序**：调用 C 语言标准库函数（如 `fread`）。
* **C语言库 (标准库)**：封装了底层的**系统调用 (System Call)**。
* **内核 (Kernel)**：接收系统调用请求，通过内核态的驱动程序直接控制硬件。

---

## 6. I/O 传送控制方式对比 (★核心总结)

| 特性 | 程序查询 (Polling) | 程序中断 (Interrupt) | 直接存储器存取 (DMA) |
| :--- | :--- | :--- | :--- |
| **数据流向** | 设备 $\leftrightarrow$ CPU $\leftrightarrow$ 内存 | 设备 $\leftrightarrow$ CPU $\leftrightarrow$ 内存 | 设备 $\leftrightarrow$ 内存 (不经CPU) |
| **并行性** | 完完全串行 | 部分并行 (准备数据时并行) | 高度并行 (传送过程并行) |
| **CPU 介入** | 全程参与，踏步等待 | 仅处理中断服务程序 | 仅初始化和结束处理 |
| **响应时机** | CPU 轮询时 | **当前指令执行结束时** | **当前总线周期结束时** |
| **适用场景** | 慢速、简单设备 | 中速设备、异常处理 | 高速、大批量数据传输 |

---
## 5. 典型题型分析

**【计算题：中断开销分析】**
* **题目**：CPU 频率 500MHz，外设传输率 2MB/s。接口缓存 16位（2字节）。中断服务程序需 500 个时钟周期。问：能否使用中断方式？
* **解题逻辑**：
    1.  **计算中断频率**：外设每产生 2 字节发一次中断。$f = 2\text{MB/s} \div 2\text{字节} = 10^6$ 次/秒。
    2.  **计算每秒 CPU 耗时**：$10^6 \times 500 = 5 \times 10^8$ 个周期。
    3.  **对比主频**：CPU 每秒总周期 = 500MHz = $5 \times 10^8$。
    4.  **结论**：CPU 100% 的时间都在处理中断，无法运行其他程序。**不可用中断方式，应改用 DMA**。

**【简答题：中断 vs DMA】**
* **中断响应**：在一条指令执行结束时。
* **DMA 响应**：在一个总线周期（Bus Cycle）结束时，响应更快。
* **数据流向**：中断方式数据必须流经 CPU 寄存器；DMA 数据直达内存。